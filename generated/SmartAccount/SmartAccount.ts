// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class ModuleInstalled extends ethereum.Event {
  get params(): ModuleInstalled__Params {
    return new ModuleInstalled__Params(this);
  }
}

export class ModuleInstalled__Params {
  _event: ModuleInstalled;

  constructor(event: ModuleInstalled) {
    this._event = event;
  }

  get moduleTypeId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get module(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class ModuleUninstalled extends ethereum.Event {
  get params(): ModuleUninstalled__Params {
    return new ModuleUninstalled__Params(this);
  }
}

export class ModuleUninstalled__Params {
  _event: ModuleUninstalled;

  constructor(event: ModuleUninstalled) {
    this._event = event;
  }

  get moduleTypeId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get module(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class TryExecuteUnsuccessful extends ethereum.Event {
  get params(): TryExecuteUnsuccessful__Params {
    return new TryExecuteUnsuccessful__Params(this);
  }
}

export class TryExecuteUnsuccessful__Params {
  _event: TryExecuteUnsuccessful;

  constructor(event: TryExecuteUnsuccessful) {
    this._event = event;
  }

  get batchExecutionindex(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get result(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }
}

export class SmartAccount__getExecutorsPaginatedResult {
  value0: Array<Address>;
  value1: Address;

  constructor(value0: Array<Address>, value1: Address) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddressArray(this.value0));
    map.set("value1", ethereum.Value.fromAddress(this.value1));
    return map;
  }

  getArray(): Array<Address> {
    return this.value0;
  }

  getNext(): Address {
    return this.value1;
  }
}

export class SmartAccount__getValidatorPaginatedResult {
  value0: Array<Address>;
  value1: Address;

  constructor(value0: Array<Address>, value1: Address) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddressArray(this.value0));
    map.set("value1", ethereum.Value.fromAddress(this.value1));
    return map;
  }

  getArray(): Array<Address> {
    return this.value0;
  }

  getNext(): Address {
    return this.value1;
  }
}

export class SmartAccount extends ethereum.SmartContract {
  static bind(address: Address): SmartAccount {
    return new SmartAccount("SmartAccount", address);
  }

  accountId(): string {
    let result = super.call("accountId", "accountId():(string)", []);

    return result[0].toString();
  }

  try_accountId(): ethereum.CallResult<string> {
    let result = super.tryCall("accountId", "accountId():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  entryPoint(): Address {
    let result = super.call("entryPoint", "entryPoint():(address)", []);

    return result[0].toAddress();
  }

  try_entryPoint(): ethereum.CallResult<Address> {
    let result = super.tryCall("entryPoint", "entryPoint():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getExecutorsPaginated(
    cursor: Address,
    size: BigInt
  ): SmartAccount__getExecutorsPaginatedResult {
    let result = super.call(
      "getExecutorsPaginated",
      "getExecutorsPaginated(address,uint256):(address[],address)",
      [
        ethereum.Value.fromAddress(cursor),
        ethereum.Value.fromUnsignedBigInt(size)
      ]
    );

    return new SmartAccount__getExecutorsPaginatedResult(
      result[0].toAddressArray(),
      result[1].toAddress()
    );
  }

  try_getExecutorsPaginated(
    cursor: Address,
    size: BigInt
  ): ethereum.CallResult<SmartAccount__getExecutorsPaginatedResult> {
    let result = super.tryCall(
      "getExecutorsPaginated",
      "getExecutorsPaginated(address,uint256):(address[],address)",
      [
        ethereum.Value.fromAddress(cursor),
        ethereum.Value.fromUnsignedBigInt(size)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SmartAccount__getExecutorsPaginatedResult(
        value[0].toAddressArray(),
        value[1].toAddress()
      )
    );
  }

  getValidatorPaginated(
    cursor: Address,
    size: BigInt
  ): SmartAccount__getValidatorPaginatedResult {
    let result = super.call(
      "getValidatorPaginated",
      "getValidatorPaginated(address,uint256):(address[],address)",
      [
        ethereum.Value.fromAddress(cursor),
        ethereum.Value.fromUnsignedBigInt(size)
      ]
    );

    return new SmartAccount__getValidatorPaginatedResult(
      result[0].toAddressArray(),
      result[1].toAddress()
    );
  }

  try_getValidatorPaginated(
    cursor: Address,
    size: BigInt
  ): ethereum.CallResult<SmartAccount__getValidatorPaginatedResult> {
    let result = super.tryCall(
      "getValidatorPaginated",
      "getValidatorPaginated(address,uint256):(address[],address)",
      [
        ethereum.Value.fromAddress(cursor),
        ethereum.Value.fromUnsignedBigInt(size)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SmartAccount__getValidatorPaginatedResult(
        value[0].toAddressArray(),
        value[1].toAddress()
      )
    );
  }

  isModuleInstalled(
    moduleType: BigInt,
    module: Address,
    additionalContext: Bytes
  ): boolean {
    let result = super.call(
      "isModuleInstalled",
      "isModuleInstalled(uint256,address,bytes):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(moduleType),
        ethereum.Value.fromAddress(module),
        ethereum.Value.fromBytes(additionalContext)
      ]
    );

    return result[0].toBoolean();
  }

  try_isModuleInstalled(
    moduleType: BigInt,
    module: Address,
    additionalContext: Bytes
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isModuleInstalled",
      "isModuleInstalled(uint256,address,bytes):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(moduleType),
        ethereum.Value.fromAddress(module),
        ethereum.Value.fromBytes(additionalContext)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  supportsAccountMode(mode: Bytes): boolean {
    let result = super.call(
      "supportsAccountMode",
      "supportsAccountMode(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(mode)]
    );

    return result[0].toBoolean();
  }

  try_supportsAccountMode(mode: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "supportsAccountMode",
      "supportsAccountMode(bytes32):(bool)",
      [ethereum.Value.fromFixedBytes(mode)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  supportsModule(modulTypeId: BigInt): boolean {
    let result = super.call(
      "supportsModule",
      "supportsModule(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(modulTypeId)]
    );

    return result[0].toBoolean();
  }

  try_supportsModule(modulTypeId: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "supportsModule",
      "supportsModule(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(modulTypeId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class DefaultCall extends ethereum.Call {
  get inputs(): DefaultCall__Inputs {
    return new DefaultCall__Inputs(this);
  }

  get outputs(): DefaultCall__Outputs {
    return new DefaultCall__Outputs(this);
  }
}

export class DefaultCall__Inputs {
  _call: DefaultCall;

  constructor(call: DefaultCall) {
    this._call = call;
  }
}

export class DefaultCall__Outputs {
  _call: DefaultCall;

  constructor(call: DefaultCall) {
    this._call = call;
  }
}

export class ExecuteCall extends ethereum.Call {
  get inputs(): ExecuteCall__Inputs {
    return new ExecuteCall__Inputs(this);
  }

  get outputs(): ExecuteCall__Outputs {
    return new ExecuteCall__Outputs(this);
  }
}

export class ExecuteCall__Inputs {
  _call: ExecuteCall;

  constructor(call: ExecuteCall) {
    this._call = call;
  }

  get mode(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get executionCalldata(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class ExecuteCall__Outputs {
  _call: ExecuteCall;

  constructor(call: ExecuteCall) {
    this._call = call;
  }
}

export class ExecuteFromExecutorCall extends ethereum.Call {
  get inputs(): ExecuteFromExecutorCall__Inputs {
    return new ExecuteFromExecutorCall__Inputs(this);
  }

  get outputs(): ExecuteFromExecutorCall__Outputs {
    return new ExecuteFromExecutorCall__Outputs(this);
  }
}

export class ExecuteFromExecutorCall__Inputs {
  _call: ExecuteFromExecutorCall;

  constructor(call: ExecuteFromExecutorCall) {
    this._call = call;
  }

  get mode(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get executionCalldata(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class ExecuteFromExecutorCall__Outputs {
  _call: ExecuteFromExecutorCall;

  constructor(call: ExecuteFromExecutorCall) {
    this._call = call;
  }
}

export class ExecuteUserOpCall extends ethereum.Call {
  get inputs(): ExecuteUserOpCall__Inputs {
    return new ExecuteUserOpCall__Inputs(this);
  }

  get outputs(): ExecuteUserOpCall__Outputs {
    return new ExecuteUserOpCall__Outputs(this);
  }
}

export class ExecuteUserOpCall__Inputs {
  _call: ExecuteUserOpCall;

  constructor(call: ExecuteUserOpCall) {
    this._call = call;
  }

  get userOp(): ExecuteUserOpCallUserOpStruct {
    return changetype<ExecuteUserOpCallUserOpStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }
}

export class ExecuteUserOpCall__Outputs {
  _call: ExecuteUserOpCall;

  constructor(call: ExecuteUserOpCall) {
    this._call = call;
  }
}

export class ExecuteUserOpCallUserOpStruct extends ethereum.Tuple {
  get sender(): Address {
    return this[0].toAddress();
  }

  get nonce(): BigInt {
    return this[1].toBigInt();
  }

  get initCode(): Bytes {
    return this[2].toBytes();
  }

  get callData(): Bytes {
    return this[3].toBytes();
  }

  get accountGasLimits(): Bytes {
    return this[4].toBytes();
  }

  get preVerificationGas(): BigInt {
    return this[5].toBigInt();
  }

  get maxFeePerGas(): BigInt {
    return this[6].toBigInt();
  }

  get maxPriorityFeePerGas(): BigInt {
    return this[7].toBigInt();
  }

  get paymasterAndData(): Bytes {
    return this[8].toBytes();
  }

  get signature(): Bytes {
    return this[9].toBytes();
  }
}

export class InitializeAccountCall extends ethereum.Call {
  get inputs(): InitializeAccountCall__Inputs {
    return new InitializeAccountCall__Inputs(this);
  }

  get outputs(): InitializeAccountCall__Outputs {
    return new InitializeAccountCall__Outputs(this);
  }
}

export class InitializeAccountCall__Inputs {
  _call: InitializeAccountCall;

  constructor(call: InitializeAccountCall) {
    this._call = call;
  }

  get data(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class InitializeAccountCall__Outputs {
  _call: InitializeAccountCall;

  constructor(call: InitializeAccountCall) {
    this._call = call;
  }
}

export class InstallModuleCall extends ethereum.Call {
  get inputs(): InstallModuleCall__Inputs {
    return new InstallModuleCall__Inputs(this);
  }

  get outputs(): InstallModuleCall__Outputs {
    return new InstallModuleCall__Outputs(this);
  }
}

export class InstallModuleCall__Inputs {
  _call: InstallModuleCall;

  constructor(call: InstallModuleCall) {
    this._call = call;
  }

  get moduleType(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get module(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get initData(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }
}

export class InstallModuleCall__Outputs {
  _call: InstallModuleCall;

  constructor(call: InstallModuleCall) {
    this._call = call;
  }
}

export class UninstallModuleCall extends ethereum.Call {
  get inputs(): UninstallModuleCall__Inputs {
    return new UninstallModuleCall__Inputs(this);
  }

  get outputs(): UninstallModuleCall__Outputs {
    return new UninstallModuleCall__Outputs(this);
  }
}

export class UninstallModuleCall__Inputs {
  _call: UninstallModuleCall;

  constructor(call: UninstallModuleCall) {
    this._call = call;
  }

  get moduleType(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get module(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get deInitData(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }
}

export class UninstallModuleCall__Outputs {
  _call: UninstallModuleCall;

  constructor(call: UninstallModuleCall) {
    this._call = call;
  }
}

export class ValidateUserOpCall extends ethereum.Call {
  get inputs(): ValidateUserOpCall__Inputs {
    return new ValidateUserOpCall__Inputs(this);
  }

  get outputs(): ValidateUserOpCall__Outputs {
    return new ValidateUserOpCall__Outputs(this);
  }
}

export class ValidateUserOpCall__Inputs {
  _call: ValidateUserOpCall;

  constructor(call: ValidateUserOpCall) {
    this._call = call;
  }

  get userOp(): ValidateUserOpCallUserOpStruct {
    return changetype<ValidateUserOpCallUserOpStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }

  get userOpHash(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get missingAccountFunds(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class ValidateUserOpCall__Outputs {
  _call: ValidateUserOpCall;

  constructor(call: ValidateUserOpCall) {
    this._call = call;
  }

  get validSignature(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class ValidateUserOpCallUserOpStruct extends ethereum.Tuple {
  get sender(): Address {
    return this[0].toAddress();
  }

  get nonce(): BigInt {
    return this[1].toBigInt();
  }

  get initCode(): Bytes {
    return this[2].toBytes();
  }

  get callData(): Bytes {
    return this[3].toBytes();
  }

  get accountGasLimits(): Bytes {
    return this[4].toBytes();
  }

  get preVerificationGas(): BigInt {
    return this[5].toBigInt();
  }

  get maxFeePerGas(): BigInt {
    return this[6].toBigInt();
  }

  get maxPriorityFeePerGas(): BigInt {
    return this[7].toBigInt();
  }

  get paymasterAndData(): Bytes {
    return this[8].toBytes();
  }

  get signature(): Bytes {
    return this[9].toBytes();
  }
}
